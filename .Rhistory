verbatimTextOutput("dataInfo")
),
server = function(input, output) {
# reactiveValues object for storing current data set.
vals <- reactiveValues(data = NULL)
# Return the UI for a modal dialog with data selection input. If 'failed' is
# TRUE, then display a message that the previous value was invalid.
dataModal <- function(failed = FALSE) {
modalDialog(
textInput("dataset", "Choose data set",
placeholder = 'Try "mtcars" or "abc"'
),
span('(Try the name of a valid data object like "mtcars", ',
'then a name of a non-existent object like "abc")'),
if (failed)
div(tags$b("Invalid name of data object", style = "color: red;")),
footer = tagList(
modalButton("Cancel"),
actionButton("ok", "OK")
)
)
}
# Show modal when button is clicked.
observeEvent(input$show, {
showModal(dataModal())
})
# When OK button is pressed, attempt to load the data set. If successful,
# remove the modal. If not show another modal, but this time with a failure
# message.
observeEvent(input$ok, {
# Check that data object exists and is data frame.
if (!is.null(input$dataset) && nzchar(input$dataset) &&
exists(input$dataset) && is.data.frame(get(input$dataset))) {
vals$data <- get(input$dataset)
removeModal()
} else {
showModal(dataModal(failed = TRUE))
}
})
# Display information about selected data
output$dataInfo <- renderPrint({
if (is.null(vals$data))
"No data selected"
else
summary(vals$data)
})
}
)
}
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Somewhat important message",
"This is a somewhat important message.",
easyClose = TRUE,
footer = NULL
))
})
}
)
shinyApp(
ui = basicPage(
actionButton("show", "Show modal dialog")
),
server = function(input, output) {
observeEvent(input$show, {
showModal(modalDialog(
title = "Important message",
"This is an important message!"
))
})
}
)
runApp()
runApp()
runApp()
runApp()
runApp()
datos_reactive$data
View(datos)
datos
datos[1,]
datos[1,]$filename_id
datos[1,]$`_id`
# Subimos los datos a la base de datos
db.find(query = '{"_id": 1}',datos[1,]$`_id`)
## Load data from MongoDB
db <- mongo(collection = collectionName,
db = databaseName,
url = paste0("mongodb://",options()$mongodb$host,":",options()$mongodb$port),
options = ssl_options(weak_cert_validation = TRUE))
# Subimos los datos a la base de datos
db.find(query = '{"_id": 1}',datos[1,]$`_id`)
View(db)
# Subimos los datos a la base de datos
db.find(query = '{"id": 1}',datos[1,]$`_id`)
# Subimos los datos a la base de datos
db.find(query = '{"_id": datos[1,]$`_id`}')
# Subimos los datos a la base de datos
db.find(query = {"_id": datos[1,]$`_id`})
# Subimos los datos a la base de datos
db$find(query = '{"_id": datos[1,]$`_id`}')
# Subimos los datos a la base de datos
db$find(query = '{"_id": "63d51e3d218164d1cbaa9601"}')
# Subimos los datos a la base de datos
db$find(query = '{"_id": 63d51e3d218164d1cbaa9601}')
# Subimos los datos a la base de datos
db$find(query = '{"_id": {"$oid":"63d51e3d218164d1cbaa9601"}]')
query_uid <- function(oid) {
stopifnot(is.character(oid), !anyNA(oid), length(oid) > 0L)
if (length(oid) == 1L) {
q <- list("_id" = list("$oid" = oid))
} else {
q <- list("_id" = list("$in" = lapply(oid, function(x) list("$oid" = x))))
}
jsonlite::toJSON(q, auto_unbox = TRUE, pretty = FALSE)
}
# Subimos los datos a la base de datos
db$find(query = query_uid("63d51e3d218164d1cbaa9601"))
jsonlite::toJSON(list("$set" = list("annotation_included" = datos[1,]$annotation_included,
"validated" = datos[1,]$validated)), auto_unbox = TRUE, pretty = FALSE)
# # Si se ha marcado el código y la etiqueta semántica está seleccionada.
# Actualizamos/giarda,ps eñ resiñtadp
if (input[[name_checkbox_code]] ==TRUE & !(is.null(input[[name_relbox_code]])) ){
#     print("Codigo_con_valor_true")
#     print(dicc_filt$code[i])
#     print("Semantic_relation")
#     print(input[[name_relbox_code]])
#     print("LLEGA")
#
# ACtualizamos datos reactivos y actualizamos/cambiamos datos de la tabla
datos_reactive$data[row_sel,] = update_dataframe(datos=datos_reactive$data,input=input,code= dicc_filt$code[i],name_relbox_code=name_relbox_code)
proxy1 %>% DT::replaceData(datos_reactive$data)
# Subimos los datos a la base de datos
db$find(query = query_uid("63d51e3d218164d1cbaa9601"))
df$update(query = query_uid(datos[1,]$`_id`),
'{"$set":{"annotation_included": 31}}')
jsonlite::toJSON(list("$set" = list("annotation_included" = datos[1,]$annotation_included,
"validated" = datos[1,]$validated)), auto_unbox = TRUE, pretty = FALSE)
}else{
# showModal(modalDialog(
#     title = "Selección incorrecta",
#     "No has seleccionado la etiqueta semántica del descriptor elegido.
#     Puede que la hayas seleccionado pero hayas olvidado marcar el código
#     de forma explicita. "
# ))
# NO GUARDAMOS NADA.
}
# # Si se ha marcado el código y la etiqueta semántica está seleccionada.
# Actualizamos/giarda,ps eñ resiñtadp
if (input[[name_checkbox_code]] ==TRUE & !(is.null(input[[name_relbox_code]])) ){
#     print("Codigo_con_valor_true")
#     print(dicc_filt$code[i])
#     print("Semantic_relation")
#     print(input[[name_relbox_code]])
#     print("LLEGA")
#
# ACtualizamos datos reactivos y actualizamos/cambiamos datos de la tabla
datos_reactive$data[row_sel,] = update_dataframe(datos=datos_reactive$data,input=input,code= dicc_filt$code[i],name_relbox_code=name_relbox_code)
proxy1 %>% DT::replaceData(datos_reactive$data)
# Subimos los datos a la base de datos
db$find(query = query_uid("63d51e3d218164d1cbaa9601"))
df$update(query = query_uid(datos[1,]$`_id`),
'{"$set":{"annotation_included": 31}}')
jsonlite::toJSON(list("$set" = list("annotation_included" = datos[1,]$annotation_included,
"validated" = datos[1,]$validated)), auto_unbox = TRUE, pretty = FALSE)
}else{
# showModal(modalDialog(
#     title = "Selección incorrecta",
#     "No has seleccionado la etiqueta semántica del descriptor elegido.
#     Puede que la hayas seleccionado pero hayas olvidado marcar el código
#     de forma explicita. "
# ))
# NO GUARDAMOS NADA.
}
jsonlite::toJSON(list("$set" = list("annotation_included" = datos[1,]$annotation_included,
"validated" = datos[1,]$validated)), auto_unbox = TRUE, pretty = FALSE)
runApp()
datos[row_sel,]
datos[row_sel,1]
runApp()
df$update(query = query_uid(datos[1,1]),
jsonlite::toJSON(list("$set" = list("annotation_included" = "TRUE#TRUE#TRUE#1321312#FALSE",
"validated" = "1")), auto_unbox = TRUE, pretty = FALSE)
)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
context_id
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
ui <- fluidPage(
spsDepend("shinyCatch"), # optional
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
ui <- fluidPage(
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
server <- function(input, output, session) {
fn_warning <- function() {
warning("this is a warning!")
return("warning returns")
}
observeEvent(input$btn1, {
shinyCatch(stop("error with blocking"), blocking_level = "error")
output$text <- renderPrint("You shouldn't see me")
})
observeEvent(input$btn2, {
shinyCatch(stop("error without blocking"))
output$text <- renderPrint("I am not blocked by error")
})
observeEvent(input$btn3, {
return_value <- shinyCatch(fn_warning())
output$text <- renderPrint("warning and blocked")
})
observeEvent(input$btn4, {
return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
print(return_value)
output$text <- renderPrint("other things")
})
observeEvent(input$btn5, {
shinyCatch(message("some message"))
output$text <- renderPrint("some message")
})
}
shinyApp(ui, server)
ui <- fluidPage(
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
server <- function(input, output, session) {
fn_warning <- function() {
warning("this is a warning!")
return("warning returns")
}
observeEvent(input$btn1, {
shinyCatch(stop("error with blocking"), blocking_level = "error")
output$text <- renderPrint("You shouldn't see me")
})
observeEvent(input$btn2, {
shinyCatch(stop("error without blocking"))
output$text <- renderPrint("I am not blocked by error")
})
observeEvent(input$btn3, {
return_value <- shinyCatch(fn_warning())
output$text <- renderPrint("warning and blocked")
})
observeEvent(input$btn4, {
return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
print(return_value)
output$text <- renderPrint("other things")
})
observeEvent(input$btn5, {
shinyCatch(message("some message"))
output$text <- renderPrint("some message")
})
}
shinyApp(ui, server)
ui <- fluidPage(
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
server <- function(input, output, session) {
fn_warning <- function() {
warning("this is a warning!")
return("warning returns")
}
observeEvent(input$btn1, {
shinyCatch(stop("error with blocking"), blocking_level = "error")
output$text <- renderPrint("You shouldn't see me")
})
observeEvent(input$btn2, {
shinyCatch(stop("error without blocking"))
output$text <- renderPrint("I am not blocked by error")
})
observeEvent(input$btn3, {
return_value <- shinyCatch(fn_warning())
output$text <- renderPrint("warning and blocked")
})
observeEvent(input$btn4, {
return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
print(return_value)
output$text <- renderPrint("other things")
})
observeEvent(input$btn5, {
shinyCatch(message("some message"))
output$text <- renderPrint("some message")
})
}
shinyApp(ui, server)
install.packages("spsComps")
ui <- fluidPage(
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
server <- function(input, output, session) {
fn_warning <- function() {
warning("this is a warning!")
return("warning returns")
}
observeEvent(input$btn1, {
shinyCatch(stop("error with blocking"), blocking_level = "error")
output$text <- renderPrint("You shouldn't see me")
})
observeEvent(input$btn2, {
shinyCatch(stop("error without blocking"))
output$text <- renderPrint("I am not blocked by error")
})
observeEvent(input$btn3, {
return_value <- shinyCatch(fn_warning())
output$text <- renderPrint("warning and blocked")
})
observeEvent(input$btn4, {
return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
print(return_value)
output$text <- renderPrint("other things")
})
observeEvent(input$btn5, {
shinyCatch(message("some message"))
output$text <- renderPrint("some message")
})
}
shinyApp(ui, server)
library(spsComps)
ui <- fluidPage(
h4("Run this example on your own computer to better understand exception
catch and dual-end logging", class = "text-center"),
column(
6,
actionButton("btn1","error and blocking"),
actionButton("btn2","error no blocking"),
actionButton("btn3","warning but still returns value"),
actionButton("btn4","warning but blocking returns"),
actionButton("btn5","message"),
),
column(
6,
verbatimTextOutput("text")
)
)
server <- function(input, output, session) {
fn_warning <- function() {
warning("this is a warning!")
return("warning returns")
}
observeEvent(input$btn1, {
shinyCatch(stop("error with blocking"), blocking_level = "error")
output$text <- renderPrint("You shouldn't see me")
})
observeEvent(input$btn2, {
shinyCatch(stop("error without blocking"))
output$text <- renderPrint("I am not blocked by error")
})
observeEvent(input$btn3, {
return_value <- shinyCatch(fn_warning())
output$text <- renderPrint("warning and blocked")
})
observeEvent(input$btn4, {
return_value <- shinyCatch(fn_warning(), blocking_level = "warning")
print(return_value)
output$text <- renderPrint("other things")
})
observeEvent(input$btn5, {
shinyCatch(message("some message"))
output$text <- renderPrint("some message")
})
}
shinyApp(ui, server)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
input$valor = 0
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
remove(abbrev_id)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
renv::restore(confirm = FALSE)
shiny::runApp('app')
runApp('app')
runApp('app')
